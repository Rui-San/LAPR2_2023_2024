@startuml
skinparam monochrome true
skinparam packageStyle rectangle
skinparam shadowing false

title US005 - System Sequence Diagram (SSD)

autonumber

actor "HRM" as HRM
participant ":TeamProposalUI" as UI
participant ":TeamProposalController" as CTRL
participant ":Repositories" as REP
participant ":repositories \nRepositories" as REPS
participant ":skillRepository \nSkillRepository" as SR
participant ":collaboratorRepository \nCollaboratorRepository" as CR
participant ":teamRepository \nTeamRepository" as TR



activate HRM

    HRM -> UI : Asks to generate a new team proposal
    activate UI

        UI --> HRM : Requests data (maxteamsize, minteamsize)
    deactivate UI



    HRM -> UI : Types requested data


    |||

            activate UI
                UI --> UI : keepData(max and min team size)
                UI -> CTRL : getSkillList()

                activate CTRL

                    CTRL -> REP : getInstance()

                    activate REP

                        REP --> CTRL : repositories
                    deactivate REP
                    CTRL -> REPS : getSkillRepository()

                    activate REPS

                        REPS --> CTRL : skillRepository
                    deactivate REPS

                    CTRL -> SR : getSkillList()

                    activate SR

                    SR --> CTRL : skillList
                    deactivate SR

                    CTRL --> UI : skillList
                deactivate CTRL
                loop until no longer want to select skills
                |||
                UI --> HRM : Shows list of skills and asks to select the skills needed

            deactivate UI

            HRM -> UI : Select skills from the list
            activate UI
            UI --> UI : keepData(List<Skill> skillsNeeded)



        end loop

  |||

        loop for each skill selected

        activate UI

        UI --> HRM : Asks to specify the quantity needed of the selected skill
|||
HRM -> UI : Types the quantity needed for that skill

UI --> UI : keepData(List<Integer> quantityNeeded)

end loop
note right
                **(5) NOTE:**
                **Set of skills:**
                *Set of skills required for the team proposal;
                *Includes the skill name and the required quantity.
        end note

|||
UI -> CTRL : generateAllTeamProposals(minTeamSize,\n maxTeamSize, skillsNeeded, quantityNeeded)

activate CTRL

CTRL -> REP : getInstance()
activate REP
REP --> CTRL : repositories
deactivate REP
CTRL -> REPS : getCollaboratorRepository
activate REPS
REPS --> CTRL : collaboratorRepository
deactivate REPS
CTRL -> CR : getCollaboratorList()
activate CR
CR --> CTRL : collaboratorList
deactivate CR
|||
|||
CTRL -> REP : getInstance()
activate REP
REP --> CTRL : repositories
deactivate REP
CTRL -> REPS : getTeamRepository
activate REPS
REPS --> CTRL : teamRepository
deactivate REPS
CTRL -> TR : generateAllTeamProposals(minTeamSize, maxTeamSize,skillsNeeded, quantityNeeded, collaboratorList)
activate TR

group Verifies if the quantity of a specific skill is\n superior to the maximum team size
    TR --> TR : verifyQuantityNeeded(List<Integer> \nquantityNeeded, int maxTeamSize)
    alt quantityCorrect is true

    TR -> TR : continues with the algorithm

else quantityCorrect is false

    TR --> TR : Returns an empty List<Team> definitiveTeamList
end

end

|||

loop for each skill selected/quantity
TR -> SkillSet** : createSkillSet(skillsNeeded, quantityNeeded)
TR --> TR : skillSetList.add(skillSet)
end

TR --> TR : gatherPossibleCollaborators(collaboratorList, skillSetList);

note left
 **Possible Collaborators to join the team:**
*Collaborator is not in a team yet
*Collaborator has at least 1 skill needed for the team
end note

|||

loop for each team size (from min to max)
TR --> TR : createTeams(possibleCollaborators, minTeamSize, maxTeamSize);
|||
TR --> TR: createTeamsBySize(List<Collaborator> possibleCollaborators, int teamSize)
end
|||
TR -> TR: List<Team> teamsList
note right
all possible teams for each
size are now on the teamsList
end note
|||
loop for each team from the teamsList

TR --> TR: verifyIfSkillSetIsFulfilled(skillSetList)
alt current team satisfies all requirements and is complete

    TR -> TR : definitiveTeamList.add(team);

else current team does not satisfy all requirements
|||


end

end
|||
note right of TR
The way this entire algorithm works,at this point, the
List<Team> definitiveTeamList is sorted by efficiency,
meaning that the first team of the list has the smallest
possible number of collaborators, and the last team has
the largest number of members.
end note

TR --> CTRL : List<Team> definitiveTeamList
deactivate TR



CTRL --> UI : List<Team> teamsGenerated

deactivate CTRL
|||



    loop until team generated is accepted
 UI --> HRM : Shows team generated and asks for confirmation
 |||
 deactivate UI
HRM -> UI : Accepts or rejects the proposal.
|||
activate UI


    end
    note right
    If the user rejects the displayed team,
    the next team in the list "teamsGenerated"
    will be showed.
    end note





    activate UI
        UI -> CTRL : saveTeamProposal(teamAccepted)
        activate CTRL

        CTRL -> REP : getInstance()
        activate REP
        REP --> CTRL : repositories
        deactivate REP
        CTRL -> REPS : getTeamRepository
        activate REPS
        REPS --> CTRL : teamRepository
        deactivate REPS
        CTRL -> TR : saveTeamProposal(teamAccepted)
        activate TR
        |||
        TR --> TR : teamList.add(teamAccepted);
        |||
        TR --> CTRL : operation success
        deactivate TR

        CTRL --> UI : operation success
        deactivate CTRL

        UI --> HRM : operation success
        deactivate UI
        deactivate HRM






@enduml